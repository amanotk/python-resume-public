.. -*- coding: utf-8 -*-

.. highlight:: python
  :linenothreshold: 1

===============
NumPy配列の基本
===============

NumPyと呼ばれるライブラリの存在はPythonが広く科学技術計算に用いられるようになった最も大きな要因の一つであろう．ここでは科学技術計算で用いられる大規模データの効率的な扱いを可能にするNumPyの多次元配列オブジェクトについて学ぼう．なお，以降はこの多次元配列オブジェクトを便宜的にNumPy配列と呼ぶことにする．

  サンプルプログラム


.. contents:: この章の内容
    :depth: 2


NumPyについて
=============

`NumPy <https://numpy.org/>`_ はPythonによる科学技術計算の根幹をなすライブラリである [#numpylib]_ ．このライブラリが提供する ``numpy`` というモジュール [#module]_ を使うためには

::

  >>> import numpy as np

のようにするのが一般的である．これは ``numpy`` という名前のモジュールを ``import`` し， ``np`` という別名を付けることを意味する．別名は必ずしもつけなくてもいいし，その別名を ``np`` にする必然性は何もない．しかし，世の中のほとんどのコードがこの書き方を採用しているので，ここでも慣例に従っておこう．以降では常に ``np`` が ``numpy`` モジュールを意味するものとする．

NumPy配列(NumPyが提供する多次元配列オブジェクト)は正確には ``np.ndarray`` オブジェクトである [#np-ndarray]_．一般にPythonはスクリプト言語に分類される動作の遅い言語であるが，NumPy配列を用いることで非常に高速な数値演算が可能である．これはNumPy配列がCで実装されており，NumPy配列の演算は「うまく」使えばほとんどが(内部的には)Cのコードとして実行されるからである．詳細は以下で追々見ていくことにし，ここでは一言だけ， **Pythonで数値計算をする際にはforループは使ってはいけない** と述べるにとどめておこう [#dontusefor]_ ．


基本的な使い方
==============

まずは基礎の基礎を抑えよう．例えば配列を作る最も簡単な方法の一つとして

::

  >>> np.arange(10)
  array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

のように ``np.arange`` を使う方法がある．``np.arange`` の引数に配列の長さを指定することで連番の整数配列ができる．この例では10が指定されているので，長さ10の整数配列が生成されている．

次に :math:`0 < x < 2\pi` の範囲を等間隔に :math:`N` 分割し，その各点で :math:`\cos(x)` を計算してみよう．

::

  >>> N = 10
  >>> x = np.arange(N)/N * 2*np.pi
  >>> y = np.cos(x)

ここで整数の変数 ``N`` が配列のサイズである．2行目で配列 ``x`` を生成し，3行目でその配列の各要素について :math:`\cos(x)` の値を計算している．

ここで2行目では ``np.arange`` で生成した配列に対してスカラー値の掛け算や割り算(整数 / 整数 = 実数に注意)を実行していることが分かるだろう( ``np.pi`` は :math:`\pi` の値である)．このとき，配列の各要素に対して演算がそれぞれ実行される．同様に3行目では配列の各要素に対して ``np.cos`` の関数を呼び出し，結果として生成される新しい配列を ``y`` に代入している．このような使い方は **Fortranの配列演算の使い方と全く同じ** である．CやPythonの組み込みの配列 [#intrinsicarray]_ では当然このような書き方は許されないが，NumPy配列はあたかもFortranの配列のように使えるのである．

このようにループを使わずに配列演算を記述できると確かに非常に便利であるが，NumPy配列の本当の利点は単に簡便さではなく，その演算速度にある．例えば ``y = np.cos(x)`` を(長さ ``N`` の配列 ``x`` および ``y`` が定義されているとして)Pythonのループを使って書くならば，

::

  >>> for i in range(N):
  >>>   y[i] = np.cos(x[i])

のようになるだろう [#numpymath]_ ．ここでNumPy配列の各要素へのアクセスにはCのように ``[]`` を使って行うことに注意しよう．計算自体は同じことだが，このループはPythonで実行されるため，その演算速度は配列演算を使った場合に比べて桁違いに遅い．これは配列演算は実質的にはCで書かれたNumPyライブラリ内で実行されることになるためである．すなわち，Python上で実行される処理は遅いのだが，Pythonから呼び出した関数がCやFortranで実装されていれば，その部分についてはCやFortranで高速に処理することができるのである．

Pythonは様々なことが手軽に実現できる非常に便利な言語であるが，ネックとなるのはその処理の遅さである．(したがって，何も考えずに書くといとも簡単に遅いコードが出来上がってしまう．）NumPy配列を使うことで重たい処理だけを他の言語で書かれた高速なライブラリに押し付けることができ，手軽さと計算速度の速さを両立しているわけである．したがって， **Pythonではループ処理をするのは可能な限り避け，可能な限り配列演算を利用するのが鉄則** である．


配列オブジェクト
================

NumPy配列オブジェクト ``np.ndarray`` は多次元配列データを格納し効率的な演算を実現する．

属性
----
オブジェクトは一般に様々な属性(attribute)を持つ．NumPy配列の場合は当然ながら各要素をデータとして持つが，それに加えて以下のような属性が重要である．

dtype

  配列要素のデータ型(整数，実数，複素数など)

ndim

  次元数

size

  配列サイズ（要素数)

shape

  配列形状

これらの属性にアクセスするには ``x.dtype`` のように ``.`` を用いる．以下の例でこれらの意味を見てみよう． ``np.arange`` で生成された配列 ``x`` について見てみると，これは64bitの整数( ``int64`` )配列であり，次元数は1，は配列要素は10である．最後の形状は各次元の長さであるが，この場合は1次元配列なので ``(10,)`` となっている．例えば3次元配列で各次元の長さが 3, 4, 5 だったとすると ``(3, 4, 5, )`` がその配列の形状となる [#shapetuple]_ ．

::

  >>> x = np.arange(10)
  >>> x.dtype
  dtype('int64')
  >>> x.ndim
  1
  >>> x.size
  10
  >>> x.shape
  (10,)


データ型
--------

NumPy配列に格納されるデータ型( ``.dtype`` 属性)はほとんどの場合はCやFortranの組み込み型と同等のものである．以下に代表的なNumPyのデータ型とそれに対応するCやFortranのデータ型を示す．

.. list-table::
    :header-rows: 1
    :width: 100%
    :widths: 10, 10, 20, 20, 40

    * - NumPy
      - 型コード
      - C
      - Fortran
      - 備考
    * - ``np.int32``
      - ``'i4'``
      - ``int32_t``
      - ``integer(4)`` / ``integer``
      - 32ビット整数(通常はCの ``int`` ，NumPyの ``'i'`` )
    * - ``np.int64``
      - ``'i8'``
      - ``int64_t``
      - ``integer(8)``
      - 64ビット整数(通常はCの ``long`` ，NumPyの ``'l'`` )
    * - ``np.uint32``
      - ``'u4'``
      - ``uint32_t``
      - 
      - 32ビット符号なし整数(通常はCの ``unsigned int`` )
    * - ``np.uint64``
      - ``'u8'``
      - ``uint64_t``
      - 
      - 64ビット符号なし整数(通常はCの ``unsigned long`` )
    * - ``np.float32``
      - ``'f4'``
      - ``float``
      - ``real(4)`` / ``real``
      - 32ビット浮動小数点数(通常はNumPyの ``'f'`` )
    * - ``np.float64``
      - ``'f8'``
      - ``double``
      - ``real(8)``
      - 64ビット浮動小数点数(通常はNumPyの ``'d'`` ，Python組み込みの ``float`` )
    * - ``np.complex64``
      - ``'c8'``
      - ``float complex``
      - ``complex(4)`` / ``complex``
      - 実部・虚部が共に32ビット浮動小数点数の複素数
    * - ``np.complex128``
      - ``'c16'``
      - ``double complex``
      - ``complex(8)``
      - 実部・虚部が共に32ビット浮動小数点数の複素数(Python組み込みの ``complex`` )

少し古いデータ型の指定方法では一文字の型コードが使われていた．例えば

::

  >>> np.dtype('d')
  dtype('float64')
  >>> np.dtype('i')
  dtype('int32')

の例では ``'d'`` は ``np.float64`` ， ``i`` は ``np.int32`` に対応している．しかし，これは環境に依存して変わってしまう可能性がある(例えば ``'i'`` が 64ビット整数 ``np.int64`` の環境もあってもおかしくはない）ので，NumPyでは明示的にデータサイズを示した ``np.int32`` のような指定が推奨されている．


生成
====

配列を生成するにはいくつかの方法があるが，以下に何もないところから配列を作るための典型的な例をいくつか示そう．

arange
------

すでに見たように ``np.arange`` は連番の配列を作る．いくつか別の使い方も見てみよう．

::

  >>> np.arange(10, 20, 2)
  array([10, 12, 14, 16, 18])

のように生成される配列の始点，終点，ステップを指定することもできる．指定の仕方は ``for`` ループでよく用いられる ``range`` と同様である．また，


::

  >>> np.arange(10, dtype=np.float64)
  array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])

のように ``dtype`` を指定することで，生成される配列のデータ型を指定することもできる．

zeros
-----

``np.zeros`` は0で初期化された配列を作るための関数である．以下の例

::

  >>> np.zeros(10)
  array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])

ではサイズが10の実数配列を生成している．デフォルトのデータ型が倍精度実数( ``np.float64`` )であることに注意しよう．このデータ型は ``dtype`` オプションで指定することができる．

多次元の配列を生成するには，以下のように形状を指定すればよい．

::

  >>> np.zeros((2, 4), dtype=np.int32)
  array([[0, 0, 0, 0],
         [0, 0, 0, 0]], dtype=int32)

この例では形状として ``(2, 4)`` を指定しているので0で初期化された2次元配列ができている．

さらに ``np.zeros_like`` を使うと，既に存在する別の配列と同じ形状・同じデータ型の配列を生成することもできる．

::

  >>> x = np.zeros((3, 3), dtype=np.float32)
  >>> np.zeros_like(x)
  array([[0., 0., 0.],
         [0., 0., 0.],
         [0., 0., 0.]], dtype=float32)

ones
----

``np.ones`` は1で初期化する以外は ``np.zeros`` と同じように使うことができる．例えば以下は2次元の配列を生成する．

::

  >>> np.ones((3, 3))
  array([[1., 1., 1.],
         [1., 1., 1.],
         [1., 1., 1.]])

ここでもデフォルトのデータ型が倍精度実数であることに注意しよう．

同様に ``np.ones_like`` も ``np.zeros_like`` の代わりに使うことができる．

::

  >>> x = np.zeros((3, 3), dtype=np.float32)
  >>> np.ones_like(x)
  array([[1., 1., 1.],
         [1., 1., 1.],
         [1., 1., 1.]], dtype=float32)

この例のように引数で与えられた配列の形状およびデータ型だけを受け継ぎ，その値は1で初期化されていることに注意しよう．

linspace
--------

ある区間を均等に区切った点列を配列として作成したいときに便利なのが ``np.linspace`` である．例えば :math:`0 \leq x \leq 1` を均等に区切った配列を生成してみよう．

::

  >>> np.linspace(0.0, 1.0, 11)
  array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ])

ここで ``np.linspace`` がデフォルトで端点(この場合は :math:`x = 0` と :math:`x = 1` )を含むことに注意しよう． :math:`x = 1` を含まなくても良いのであれば ``np.arange`` を用いて

::

  >>> np.arange(10)/10
  array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])

としてもよい．

geomspace / logspace
--------------------

To be written.

シーケンス型からの生成
----------------------

To be written.

入出力
======

NumPyは配列の入出力用に便利な関数が用意されており，非常に簡単に使うことができる．

テキスト入出力
--------------

loadtxt
+++++++
いわゆるCSV(comma-separated values)ファイルを読み込むには ``np.loadtxt`` が大変便利である．


savetxt
+++++++
``np.loadtxt`` の逆にCSV形式で配列をファイルに出力する．


バイナリ入出力
--------------

To be written.

基本的な演算
============

To be written.

インデックス操作
================

To be written.

形状操作
========

To be written.



..
.. 課題
..

.. .. include:: kadai/chap04_kadai.rst

-----

.. [#numpylib]

   これはPythonに組み込みのライブラリではないので別途インストールする必要があるが，ほとんどの環境には入っていると思われるのでここではあるものとして考える．

.. [#module]

   ここではモジュールが何なのかについてはあえて触れない．これを知らなくてもNumPy配列は十分に使いこなすことができる．

.. [#np-ndarray]

   正確にはクラス ``np.ndarray`` のインスタンスと呼ぶべきかもしれないが，ここでは細かいことは置いておこう．

.. [#dontusefor]

   もちろんこれは誇張なわけだが，この考え方は非常に重要である．ほとんどの場合はループを使わずに書くことができ，これによって飛躍的に高速な実行が可能となるからである．

.. [#numpymath]

   このようにNumPyの数学関数はスカラーに対してもNumPy配列に対しても有効である．さらに，標準の ``math`` モジュールよりも多くの数学関数が用意されているので，特に理由がない限りは常にNumPyの数学関数を用いるのが簡単であろう．

.. [#intrinsicarray]

   Pythonにも配列を提供する ``array`` という組み込みのモジュールがあるのだが，NumPy配列があまりにも便利で普及しているのでそれほどお目にかかることはないだろう．

.. [#shapetuple]

   配列の形状はタプル(tuple)というオブジェクトとして表されている．タプルは簡単に言うと変更できない配列のようなものである．
