.. -*- coding: utf-8 -*-

.. highlight:: python
  :linenothreshold: 1

=================
 NumPy配列の基本
=================

NumPyと呼ばれるライブラリの存在はPythonが広く科学技術計算に用いられるようになった最も大きな要因の一つであろう．ここでは科学技術計算で用いられる大規模データの効率的な扱いを可能にするNumPyの多次元配列オブジェクトについて学ぼう．なお，以降はこの多次元配列オブジェクトを便宜的にNumPy配列と呼ぶことにする．

.. seealso::

  `sample.ipynb <sample/chap06/sample.html>`_ (`ダウンロード <sample/chap06/sample.ipynb>`_)

.. contents:: この章の内容
    :depth: 2


NumPyについて
=============

`NumPy <https://numpy.org/>`_ はPythonによる科学技術計算の根幹をなすライブラリである [#numpylib]_ ．このライブラリが提供する ``numpy`` というモジュールを使うためには

::

  >>> import numpy as np

のようにするのが一般的である．これは ``numpy`` という名前のモジュールを ``import`` し， ``np`` という別名を付けることを意味する．別名は必ずしもつけなくてもいいし，その別名を ``np`` にする必然性は何もない．しかし，世の中のほとんどのコードがこの書き方を採用しているので，ここでも慣例に従っておこう．以降では常に ``np`` が ``numpy`` モジュールを意味するものとする．

NumPy配列(NumPyが提供する多次元配列オブジェクト)は正確には ``np.ndarray`` オブジェクトである [#np-ndarray]_．一般にPythonはスクリプト言語に分類される動作の遅い言語であるが，NumPy配列を用いることで非常に高速な数値演算が可能となる．これはNumPy配列がCで実装されており，NumPy配列の演算は「うまく」使えばほとんどが内部的にはCのコードとして実行されるからである．詳細は以下で追々見ていくことにしよう．


基本的な使い方
==============

まずは基礎の基礎を抑えよう．例えば配列を作る最も簡単な方法の一つとして

::

  >>> np.arange(10)
  array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

のように ``np.arange()`` を使う方法がある．``np.arange()`` の引数に配列の長さを指定することで連番の整数配列ができる．この例では10が指定されているので，長さ10の整数配列が生成されている．

次に :math:`0 < x < 2\pi` の範囲を等間隔に :math:`N` 分割し，その各点で :math:`\cos(x)` を計算してみよう．

::

  >>> N = 10
  >>> x = np.arange(N)/N * 2*np.pi
  >>> y = np.cos(x)

ここで整数の変数 ``N`` が配列のサイズである．2行目で配列 ``x`` を生成し，3行目でその配列の各要素について :math:`\cos(x)` の値を計算している．

ここで2行目では ``np.arange()`` で生成した配列に対してスカラー値の掛け算や割り算(整数 / 整数 = 実数に注意)を実行していることが分かるだろう( ``np.pi`` は :math:`\pi` の値である)．このとき，配列の各要素に対して演算がそれぞれ実行される．同様に3行目では配列の各要素に対して ``np.cos()`` 関数を呼び出し，結果として生成される新しい配列を ``y`` に代入している．このような使い方は **Fortranの配列演算の使い方と全く同じ** である．CやPythonの組み込みの配列 [#intrinsicarray]_ では当然このような書き方は許されないが，NumPy配列はあたかもFortranの配列のように使えるのである．

このようにループを使わずに配列演算を記述できると確かに非常に便利であるが，NumPy配列の本当の利点は単に簡便さではなく，その演算速度にある．例えば ``y = np.cos(x)`` を(長さ ``N`` の配列 ``x`` および ``y`` が定義されているとして)Pythonのループを使って書くならば，

::

  >>> for i in range(N):
  >>>   y[i] = np.cos(x[i])

のようになるだろう [#numpymath]_ ．ここでNumPy配列の各要素へのアクセスにはCのように ``[]`` を使って行うことに注意しよう．計算自体は同じことだが，このループはPythonで実行されるため，その演算速度は配列演算を使った場合に比べて桁違いに遅い．これは配列演算は実質的にはCで書かれたNumPyライブラリ内で実行されることになるためである．すなわち，Python上で実行される処理は遅いのだが，Pythonから呼び出した関数がCやFortranで実装されていれば，その部分についてはCやFortranで高速に処理することができるのである．

Pythonは様々なことが手軽に実現できる非常に便利な言語であるが，ネックとなるのはその処理の遅さである．(したがって，何も考えずに書くといとも簡単に遅いコードが出来上がってしまう．）NumPy配列を使うことで重たい処理だけを他の言語で書かれた高速なライブラリに押し付けることができ，手軽さと計算速度の速さを両立しているわけである．したがって， **Pythonではループ処理をするのは可能な限り避け，可能な限り配列演算を利用するのが鉄則** である．


配列オブジェクト
================

NumPy配列オブジェクト ``np.ndarray`` は多次元配列データを格納し効率的な演算を実現する．

属性
----
NumPy配列の場合は当然ながら各要素をデータとして持つが，それに加えて以下の属性が重要である．

.. list-table::
    :header-rows: 1
    :width: 100%
    :widths: 20, 80

    * - 属性
      - 意味
    * - ``dtype``
      - 配列要素のデータ型(整数，実数，複素数など)
    * - ``ndim``
      - 次元数
    * - ``size``
      - 配列サイズ（要素数)
    * - ``shape``
      - 配列形状

以下の例を見てみよう． ``np.arange()`` で生成された配列 ``x`` について見てみると，これは64bitの整数( ``int64`` )配列であり，次元数は1，は配列サイズは10である．最後の形状は各次元の長さをtupleで表したものであるが，この場合は1次元配列なので ``(10,)`` となっている．例えば3次元配列で各次元の長さが 3, 4, 5 だったとすると ``(3, 4, 5, )`` がその配列の形状となる．

::

  >>> x = np.arange(10)
  >>> x.dtype
  dtype('int64')
  >>> x.ndim
  1
  >>> x.size
  10
  >>> x.shape
  (10,)
  >>> np.array([[1, 2, 3], [4, 5, 6]]).shape
  (2, 3)


データ型
--------

NumPy配列に格納されるデータ型( ``.dtype`` 属性)はほとんどの場合はCやFortranの組み込み型と同等のものである．以下に代表的なNumPyのデータ型とそれに対応するCやFortranのデータ型を示す．

.. list-table::
    :header-rows: 1
    :width: 100%
    :widths: 10, 10, 20, 20, 40

    * - NumPy
      - 型コード
      - C
      - Fortran
      - 備考
    * - ``np.int32``
      - ``'i4'``
      - ``int32_t``
      - ``integer(4)`` / ``integer``
      - 32ビット整数(通常はCの ``int`` ，NumPyの ``'i'`` )
    * - ``np.int64``
      - ``'i8'``
      - ``int64_t``
      - ``integer(8)``
      - 64ビット整数(通常はCの ``long`` ，NumPyの ``'l'`` )
    * - ``np.uint32``
      - ``'u4'``
      - ``uint32_t``
      - 
      - 32ビット符号なし整数(通常はCの ``unsigned int`` )
    * - ``np.uint64``
      - ``'u8'``
      - ``uint64_t``
      - 
      - 64ビット符号なし整数(通常はCの ``unsigned long`` )
    * - ``np.float32``
      - ``'f4'``
      - ``float``
      - ``real(4)`` / ``real``
      - 32ビット浮動小数点数(通常はNumPyの ``'f'`` )
    * - ``np.float64``
      - ``'f8'``
      - ``double``
      - ``real(8)``
      - 64ビット浮動小数点数(通常はNumPyの ``'d'`` ，Python組み込みの ``float`` )
    * - ``np.complex64``
      - ``'c8'``
      - ``float complex``
      - ``complex(4)`` / ``complex``
      - 実部・虚部が共に32ビット浮動小数点数の複素数
    * - ``np.complex128``
      - ``'c16'``
      - ``double complex``
      - ``complex(8)``
      - 実部・虚部が共に32ビット浮動小数点数の複素数(Python組み込みの ``complex`` )

少し古いデータ型の指定方法では一文字の型コードが使われていた．例えば

::

  >>> np.dtype('d')
  dtype('float64')
  >>> np.dtype('i')
  dtype('int32')

の例では ``'d'`` は ``np.float64`` ， ``i`` は ``np.int32`` に対応している．しかし，これは環境に依存して変わってしまう可能性がある(例えば ``'i'`` が 64ビット整数 ``np.int64`` の環境もあってもおかしくはない）ので，NumPyでは明示的にデータサイズを示した ``np.int32`` のような指定が推奨されている．


生成
====

配列を生成するにはいくつかの方法があるが，以下に何もないところから配列を作るための典型的な例をいくつか示そう．

シーケンス型からの生成
----------------------

既存のlistやtupleを ``np.array()`` 関数の引数に与えることでNumPy配列に変換することができる．使い方は以下の例を見れば明らかであろう．

::

  >>> np.array([0, 1, 2, 3, 4])              # list [0, 1, 2, 3, 4] を変換
  array([0, 1, 2, 3, 4])
  >>> np.array((0, 1, 2))                    # tuple (0, 1, 2) を変換
  array([0, 1, 2])
  >>> np.array([[0, 1,], [2, 3], [4, 5]])    # listのlistを2次元配列に変換
  array([[0, 1],
         [2, 3],
         [4, 5]])


arange
------

すでに見たように ``np.arange()`` は連番の配列を作る．いくつか別の使い方も見てみよう．

::

  >>> np.arange(10, 20, 2)
  array([10, 12, 14, 16, 18])

のように生成される配列の始点，終点，ステップを指定することもできる．指定の仕方は ``for`` ループでよく用いられる ``range()`` と同様である．また，


::

  >>> np.arange(10, dtype=np.float64)
  array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])

のように ``dtype`` を指定することで，生成される配列のデータ型を指定することもできる．


zeros
-----

``np.zeros()`` は0で初期化された配列を作るための関数である．以下の例

::

  >>> np.zeros(10)
  array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])

ではサイズが10の実数配列を生成している．デフォルトのデータ型が倍精度実数( ``np.float64`` )であることに注意しよう．このデータ型は ``dtype`` オプションで指定することができる．

多次元の配列を生成するには，以下のように形状を指定すればよい．

::

  >>> np.zeros((2, 4), dtype=np.int32)
  array([[0, 0, 0, 0],
         [0, 0, 0, 0]], dtype=int32)

この例では形状として ``(2, 4)`` を指定しているので0で初期化された2次元配列ができている．

さらに ``np.zeros_like()`` を使うと，既に存在する別の配列と同じ形状・同じデータ型の配列を生成することもできる．

::

  >>> x = np.zeros((3, 3), dtype=np.float32)
  >>> np.zeros_like(x)
  array([[0., 0., 0.],
         [0., 0., 0.],
         [0., 0., 0.]], dtype=float32)


ones
----

``np.ones()`` は1で初期化する以外は ``np.zeros()`` と同じように使うことができる．例えば以下は2次元の配列を生成する．

::

  >>> np.ones((3, 3))
  array([[1., 1., 1.],
         [1., 1., 1.],
         [1., 1., 1.]])

ここでもデフォルトのデータ型が倍精度実数であることに注意しよう．

同様に ``np.ones_like()`` も ``np.zeros_like()`` の代わりに使うことができる．

::

  >>> x = np.zeros((3, 3), dtype=np.float32)
  >>> np.ones_like(x)
  array([[1., 1., 1.],
         [1., 1., 1.],
         [1., 1., 1.]], dtype=float32)

この例のように引数で与えられた配列の形状およびデータ型だけを受け継ぎ，その値は1で初期化されていることに注意しよう．


linspace
--------

ある区間を均等に区切った点列を配列として作成したいときに便利なのが ``np.linspace()`` である．例えば :math:`0 \leq x \leq 1` を均等に区切った配列を生成してみよう．

::

  >>> np.linspace(0.0, 1.0, 11)
  array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ])

ここで ``np.linspace()`` がデフォルトで端点(この場合は :math:`x = 0` と :math:`x = 1` )を含むことに注意しよう． :math:`x = 1` を含まなくても良いのであれば ``np.arange()`` を用いて

::

  >>> np.arange(10)/10
  array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])

としてもよい．


geomspace / logspace
--------------------

``np.linspace()`` によってある区間 :math:`[a, b]` を線形に均等に区切ることができた．同様に与えられた区間を対数スケールで等間隔に区切るために ``np.geomspace()`` と ``np.logspace()`` が提供されている．この両者の違いは ``np.geomspace()`` には区間の端点の値をそのまま引数として指定するのに対して， ``np.logspace()`` には :math:`\log_{10}(a)` および :math:`\log_{10}(b)` を引数として渡すことである．

::

  >>> np.geomspace(0.1, 10.0, 11)  # [0.1,10]をlogで等間隔に区切る
  array([ 0.1       ,  0.15848932,  0.25118864,  0.39810717,  0.63095734,
          1.        ,  1.58489319,  2.51188643,  3.98107171,  6.30957344,
         10.        ])
  >>> np.logspace(-1, +1, 11)      # 全く同じ(log10(0.1) = -1, log10(10) = +1)
  array([ 0.1       ,  0.15848932,  0.25118864,  0.39810717,  0.63095734,
          1.        ,  1.58489319,  2.51188643,  3.98107171,  6.30957344,
         10.        ])

上の2つの例は丸め誤差を除いて以下と全く同一の結果を与える．

::

  >>> 10**np.linspace(np.log10(0.1), np.log10(10.0), 11)
  array([ 0.1       ,  0.15848932,  0.25118864,  0.39810717,  0.63095734,
          1.        ,  1.58489319,  2.51188643,  3.98107171,  6.30957344,
         10.        ])


random
------

乱数配列を作るのも以下のように簡単にできる．

::

  >>> np.random.random(5)               # [0, 1)の一様乱数(長さ5の配列)
  array([0.80086594, 0.2513905 , 0.41056114, 0.14083936, 0.74182892])
  >>> np.random.randint(0, 5, size=10)  # [0, 10)の整数乱数(長さ10の配列)
  array([2, 4, 4, 3, 1, 0, 4, 2, 2, 1])
  >>> np.random.random((3, 2))          # [0, 1)の一様乱数を形状(3, 2)の2次元配列として
  array([[0.56945673, 0.5676268 ],
         [0.39896178, 0.0149435 ],
         [0.35165915, 0.93962764]])

なお，ここで ``np.random.random()`` というのは ``numpy`` モジュールの中の ``random`` モジュールの中の ``random()`` 関数という意味である．


入出力
======

NumPyは配列の入出力用に便利な関数が用意されており，非常に簡単に使うことができる．

テキスト入出力
--------------

loadtxt
~~~~~~~
テキスト形式のデータファイルを読み込むには ``np.loadtxt()`` が大変便利である．ここではデータファイル `helix1.dat <data/helix1.dat>`_ を読み込んでみよう．このファイルの中身は以下のようになっており，値がスペースで区切られている．

.. code-block:: bash

   0.81  0.59  0.50
   0.31  0.95  1.00
  (中略)
   0.81  0.59 15.50
   0.31  0.95 16.00

このファイルは以下のように1行で読み込むことができる．

::

  >>> x = np.loadtxt('helix1.dat')
  >>> x.shape
  (32, 3)

読み込んだ結果は2次元配列として返される．この場合は32行 x 3列のデータのため ``.shape`` 属性は ``(32, 3)`` となっている． ``np.loadtxt()`` には多くのオプションがあるが，重要なものは以下の通りである．

.. list-table::
    :header-rows: 1
    :width: 100%
    :widths: 20, 20, 60

    * - パラメータ名
      - データ型
      - 概要
    * - dtype
      - ``np.dtype``
      - デフォルトでは ``float`` ( ``np.float64`` )
    * - delimiter
      - ``str``
      - 値の区切り文字(デフォルトではスペース)
    * - comments
      - ``str``
      - 各行のこの文字列に続く部分はコメントとみなされ無視する（デフォルトでは ``'#'`` )
    * - skiprows
      - ``int``
      - ファイル先端から指定された行数分だけ無視する（デフォルトでは0)


例えばスペースではなくカンマ ``,`` で区切られたいわゆるCSV(Comma-Separated Values)ファイルを読み込むには

::

  >>> x = np.loadtxt('filename.csv', delimiter=',')

のように区切り文字を指定すればよい．


savetxt
~~~~~~~
``np.loadtxt()`` の逆に配列をファイルに出力するには ``np.savetxt()`` を使えばよい．例えばNumPy配列オブジェクト ``x`` をoutput.datというファイルに出力するには

::

  >>> np.savetxt('output.dat', x)

とすればよい． 代表的なオプションをいかにいくつか紹介しておこう．

.. list-table::
    :header-rows: 1
    :width: 100%
    :widths: 20, 20, 60

    * - パラメータ名
      - データ型
      - 概要
    * - fmt
      - ``str``
      - フォーマット文字列
    * - delimiter
      - ``str``
      - 値の区切り文字(デフォルトではスペース)
    * - comments
      - ``str``
      - ヘッダー・フッター用のコメント文字（デフォルトでは ``'#'`` )
    * - header
      - ``str``
      - ファイル先端のコメントヘッダー
    * - footer
      - ``str``
      - ファイル終端のコメントフッター

例えば `helix1.dat <data/helix1.dat>`_ を読み込み，同じフォーマットで別のファイルoutput.datに書き込むには

::

  >>> x = np.loadtxt('helix1.dat')
  >>> np.savetxt('output.dat', x, fmt='%5.2f')

のようにフォーマット文字列を指定すればよい．


バイナリ入出力
--------------

To be written.

各種演算
========

算術演算
--------
以下の例を見れば一目瞭然であろう．基本的にFortranの配列と同様な演算ができると思ってよい．

::

  >>> a = np.arange(4)
  >>> b = np.arange(4) + 4
  >>> a + b
  array([ 4,  6,  8, 10])
  >>> a - b
  array([-4, -4, -4, -4])
  >>> a * b
  array([ 0,  5, 12, 21])
  >>> a / b
  array([0.        , 0.2       , 0.33333333, 0.42857143])
  >>> a**2
  array([0, 1, 4, 9])


ユニバーサル関数
----------------
NumPy配列を引数にとり各要素にそれぞれ適用される関数は，NumPyではユニバーサル関数( ``ufunc`` )と呼ばれている(通常の関数と同じものだと考えてよい)．よく使うであろう数学関数は全て提供されていると考えてよい [#mathfunc]_ ．Fortranなどでは提供されていない関数の使用例をいくつか示しておこう．なお，以下の例はスカラーに対して関数を呼び出しているが，配列を引数に与えた場合には各要素に対して演算した結果を返す．

::

  >>> np.deg2rad(90.0)       # degreeからradianへの変換
  1.5707963267948966
  >>> np.rad2deg(np.pi/2)    # radianからdegreeへの変換
  90.0
  >>> np.lcm(4, 6)           # 最小公倍数
  12
  >>> np.gcd(12, 20)         # 最大公約数
  4
  >>> np.angle(1.0 + 1.0j)   # 複素数の偏角
  0.7853981633974483

詳細は `公式ドキュメント <https://numpy.org/doc/stable/reference/routines.math.html>`_ を参照のこと．


メソッド
--------
NumPy配列も当然オブジェクトなのでメソッドを持つ．また，多くのメソッドにはそれと対応する関数が存在する．以下で例を見てみよう．

配列の総和を計算するには ``np.sum()`` という関数を用いることができる．

::

  >>> x = np.arange(10)
  >>> np.sum(x)
  45

これと同じことを配列 ``x`` のメソッド ``sum()`` を使って

::

  >>> x.sum()
  45

と表現することもできる．このように関数とメソッドがどちらも用意されているときにはどちらを使っても全く同じである．(メソッドの方が少しタイプ量が少ないし，タブキーでの補完を考えた時にはよいかもしれない．)
以下にもう少し例を示しておこう．

::

  >>> x.max()   # 最大値
  9
  >>> x.min()   # 最小値
  0
  >>> x.mean()  # 平均値
  4.5

単なる数値的な演算に限らず多くの便利なメソッドが用意されている．詳細は `公式ドキュメント <https://numpy.org/doc/1.18/reference/arrays.ndarray.html#array-methods>`_ を参照のこと．


インデックス操作
================

NumPyのインデックス操作は基本的にFortranの配列操作と似ているのでFortranユーザーには馴染みやすいだろう．

::

  >>> x = np.arange(10)
  >>> x[2]                 # 3番目の要素
  2
  >>> x[2:5]               # 3, 4, 5番目の要素(結果もNumPy配列)
  array([2, 3, 4])
  >>> x[:8:2] = -1         # 0, 2, 4, 6番目の要素に-1を代入
  >>> x                    # 確認
  array([-1,  1, -1,  3, -1,  5, -1,  7,  8,  9])
  >>> x[::-1]              # 順番を反転
  array([ 9,  8,  7, -1,  5, -1,  3, -1,  1, -1])
  >>> x[-1]                # 最後の要素
  9
  >>> x[-2]                # 最後から2番目の要素
  8

Fortranとの違いは負のインデックスを指定すると後ろから順に数えた要素を返すところである．実はこのようなインデックス操作はPython組み込みのシーケンス型(listなど)に対して行うこともできる．NumPy配列はこのインデックス操作をさらに強力なものにする．例えば，以下のようにインデックスを配列で渡すことも可能である．

::

  >>> i = np.arange(1, 10, 2) # インデックス配列を作成
  >>> i                       # 確認
  array([1, 3, 5, 7, 9])
  >>> x[i] *= 2               # 2倍にする
  >>> x                       # 確認
  array([-1,  2, -1,  6, -1, 10, -1, 14,  8, 18])
  >>> x[i-1]                  # インデックスを一つずらす
  array([-1, -1, -1, -1,  8])

のように使うことができる．(これは差分法に使うときなどに便利である．)

さらに，多次元配列のインデックス操作についても例を見てみよう．

::

  >>> y = np.arange(20).reshape((4, 5)) # 長さ20の配列をreshapeで2次元配列に変換
  >>> y
  array([[ 0,  1,  2,  3,  4],
         [ 5,  6,  7,  8,  9],
         [10, 11, 12, 13, 14],
         [15, 16, 17, 18, 19]])
  >>> y[0,:]                            # 1次元目は0，2次元目は全て
  array([0, 1, 2, 3, 4])
  >>> y[:,1]                            # 1次元目は全て，2次元目は1
  array([ 1,  6, 11, 16])
  >>> y[1:3,1:3]                        # 両次元とも1, 2番目の要素
  array([[ 6,  7],
         [11, 12]])

より高次元の配列を扱う際には ``...`` が便利である [#ellipsis]_ ．

::

  >>> z = np.arange(18).reshape((2, 3, 3)) # 3次元配列
  >>> z
  array([[[ 0,  1,  2],
          [ 3,  4,  5],
          [ 6,  7,  8]],
  
         [[ 9, 10, 11],
          [12, 13, 14],
          [15, 16, 17]]])
  >>> z[...,0]                             # z[:,:,0]と同じ
  array([[ 0,  3,  6],
         [ 9, 12, 15]])
  >>> z[1,...,0]                           # z[1,:,0]と同じ
  array([ 9, 12, 15])
  >>> z[1]                                 # z[1,:,:]と同じ
  array([[ 9, 10, 11],
         [12, 13, 14],
         [15, 16, 17]])

他にも色々と便利なのだがあまりにも機能が沢山あるので，これ以上は `公式ドキュメント <https://numpy.org/doc/stable/reference/arrays.indexing.html#arrays-indexing>`_ を参照して欲しい．一つだけ配列の代入について注意しておこう．

::

  >>> x[:] = 10 # 配列の全要素に10を代入
  >>> x         # 確認
  array([10, 10, 10, 10, 10, 10, 10, 10, 10, 10])
  >>> x = 10    # 整数10をxに代入
  >>> x         # xはスカラー
  10

このように1行目と4行目では動作が異なる．Fortranでは4行目のように記述しても配列の全要素に10を代入してくれるが，Pythonでは **新しい変数を作り，そこに整数10を代入** する．これは動的型付け言語のPythonならではの動作である．配列の全要素にスカラー値を代入する際にはインデックスに ``:`` (もしくは ``...`` )を指定しなければならない．


形状操作
========

配列の形状は決して固定のものではない．実はこれまでの例にも既に出てきたが，

::

  >>> x = np.arange(10)
  >>> y = x.reshape((2, 5))
  >>> x
  array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
  >>> y
  array([[0, 1, 2, 3, 4],
         [5, 6, 7, 8, 9]])

のように ``reshape()`` メソッドによって配列の形状を変更することができる．この例ではまず長さ10の1次元配列 ``x`` を作って，それを形状(2, 5)の2次元配列 ``y`` に変換している．一体何が起こっているのだろうか？試しに ``y`` の要素を変更してみよう．

::

  >>> y[1,0] = -1
  >>> x
  array([ 0,  1,  2,  3,  4, -1,  6,  7,  8,  9])
  >>> y
  array([[ 0,  1,  2,  3,  4],
         [-1,  6,  7,  8,  9]])

ここで変更したのはあくまで ``y`` の一つの要素であるが，それに伴って ``x`` の要素も変更されていることに注意しよう．すなわち， ``x`` も ``y`` もある連続したメモリブロック(この場合は8 byte x 10個 = 80 byte)への参照でしかない(つまりデータの実態は同じもの) [#sharememory]_ ． ``y`` に対しては2つのインデックスを使って要素を指定するが，これはあくまで人間から見た時の考えやすさのためにそうしてるに過ぎない．(これは何もPythonに限ったことでなく，Fortranでも同じことである．Cの場合は少し事情が複雑だが，staticな配列に限定すればやはり同じである．)

したがって，当然ながら ``reshape()`` 前後で要素数が同じである必要がある．試しに ``x`` を形状(3, 5)に変換しようとしても

::

  >>> np.arange(10).reshape((3, 5))
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  ValueError: cannot reshape array of size 10 into shape (3,5)

のようにエラーとなる．


多次元配列の連続したメモリブロックを新たな1次元配列として得るために ``ravel()`` メソッドを使うことができる．似たようなメソッドとして ``flatten()`` があるが，これらの違いはなんだろうか．

::

  >>> a = y.ravel()
  >>> b = y.flatten()
  >>> a
  array([ 0,  1,  2,  3,  4, -1,  6,  7,  8,  9])
  >>> b
  array([ 0,  1,  2,  3,  4, -1,  6,  7,  8,  9])

見た目ではどちらも同じように見える．ここで ``y`` の要素を再び変更してみよう．

::

  >>> y[1,0] = 5
  >>> a
  array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
  >>> b
  array([ 0,  1,  2,  3,  4, -1,  6,  7,  8,  9])

このように ``ravel()`` で作られた ``a`` は同じメモリブロックを参照しているのに対して， ``flatten()`` で作られた ``b`` は異なる領域を指していることが分かる．すなわち ``flatten()`` は新たなメモリブロックを確保し，データをコピーする．一方で， ``ravel()`` は単なる参照でしかない．当然 ``ravel()`` はデータをコピーする手間がない分高速に動作することに注意しよう．

なお，ここで紹介した形状操作はあくまでも初級編である．NumPyの演算速度を最大限に活かそうと思うと，このような配列形状の変更には思いのほか頻繁に出くわすことになるので少しずつ慣れていこう．

..
.. 課題
..

.. include:: kadai/chap06_kadai.rst

-----

.. [#numpylib]

   これはPythonに組み込みのライブラリではないので別途インストールする必要があるが，ほとんどの環境には入っていると思われるのでここではあるものとして考える．

.. [#np-ndarray]

   正確にはクラス ``np.ndarray`` のインスタンスと呼ぶべきかもしれないが，ここでは細かいことは置いておこう．

.. [#numpymath]

   このようにNumPyの数学関数はスカラーに対してもNumPy配列に対しても有効である．さらに，標準の ``math`` モジュールよりも多くの数学関数が用意されているので，特に理由がない限りは常にNumPyの数学関数を用いるのが簡単であろう．

.. [#intrinsicarray]

   Pythonにも配列を提供する ``array`` という組み込みのモジュールがあるのだが，NumPy配列があまりにも便利で普及しているのでそれほどお目にかかることはないだろう．

.. [#mathfunc]

   NumPyで提供されていないような特殊関数であっても，ほとんどはSciPyの特殊関数モジュール `scipy.special <https://docs.scipy.org/doc/scipy/reference/special.html>`_ に実装されているであろう．ここで提供されていない関数が必要になることは稀である．

.. [#ellipsis]

   ``...`` は ``Ellipsis`` Pythonのオブジェクトというものであり，何かが省略されていることを意味する．

.. [#sharememory]

  疑り深い人はもっと直接的に確かめてみよう． ``shares_memory()`` 関数は与えられた2つのNumPy配列が同じメモリ領域を指しているかどうかをチェックする．これを使うと

::

  >>> np.shares_memory(x, y)
  True

のように，確かに ``x`` と ``y`` が同じメモリ領域を指していることがわかる．
