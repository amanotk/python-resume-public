.. -*- coding: utf-8 -*-

.. highlight:: python
  :linenothreshold: 1

==============
制御構造と関数
==============

ここでは ``if`` による条件分岐， ``for`` や ``while`` による反復処理，さらには関数の基本的な使い方についても学ぼう．

  サンプルプログラム

  - :doc:`sample1.py <chap03_sample1_py>` : ``if`` による条件分岐
  - :doc:`sample2.py <chap03_sample2_py>` : ``for`` による反復処理
  - :doc:`sample3.py <chap03_sample3_py>` : ``while`` による反復処理
  - :doc:`sample4.py <chap03_sample4_py>` : 複雑な反復処理
  - :doc:`sample5.py <chap03_sample5_py>` : 関数の使い方1
  - :doc:`sample6.py <chap03_sample6_py>` : 関数の使い方2
  - :doc:`sample7.py <chap03_sample7_py>` : 関数の使い方3

.. contents:: この章の内容
    :depth: 2



条件分岐( ``if`` )
==================

Pythonでも基本的な考え方は他の多くのプログラミング言語と同じで，なんらかの値の真偽に応じて処理の流れを分岐する．例えば ``status`` という変数の真偽に応じて処理を分岐するには

.. literalinclude:: sample/chap03/sample1.py
  :lines: 12-16
  :lineno-match:
  :caption: :doc:`sample1.py <chap03_sample1_py>` 抜粋

のように記述すればよい．ここでインデントが構文ブロックの区切りであったことを思い出して欲しい． ``if`` に限らず至るところでインデントが必要になるので注意しよう．

なお ``else`` 節は必要なければ省略することが可能である．CやFortranと異なり，条件式の部分にカッコが必要ないことに注意しよう．（ただしカッコがあっても文法的には誤りではない．）さらに， ``if`` を入れ子にするなどのより細かい制御の例として以下を見てみよう．

.. literalinclude:: sample/chap03/sample1.py
  :lines: 25-47
  :lineno-match:
  :caption: :doc:`sample1.py <chap03_sample1_py>` 抜粋

なお46行目の ``pass`` は「何もしない」という意味の文である． ``else`` 節は省略できるので，わざわざここに ``pass`` は使う必要はないのだが，場合によっては「何もしない」ことを明示しておくことでプログラムが理解しやすくなることもある．


ここで分岐に使う条件式についてもコメントしておこう．Fortranでは条件式は真偽値(``logical`` 型の変数，または ``.true.`` ， ``.false.`` のいずれか)に限られていた．それに対して，Pythonの場合はCに近くなっている．すなわち，Python組み込みのbool型である ``True`` や ``False`` （これらはPythonの予約済みキーワードで大文字小文字は区別される）だけでなく，任意の型の変数を使うことが出来る．詳細は省くが，とりあえずはCと同様に整数型では ``0`` が偽とみなされ，それ以外は真とみなされるとおぼえておけばよいだろう．また複雑な条件判定には論理演算子である ``and`` ， ``or`` ， ``not`` を組合わせることになる．以下のテーブルには条件判定によく使われる演算子およびその組み合わせの代表的な例を示す．なお，PythonはCやFortranよりも演算子が多い(例えば ``is`` 演算子)のだが，ここではそれには触れないことにする．

.. tabularcolumns:: |p{0.3 \textwidth}|p{0.3 \textwidth}|p{0.3 \textwidth}|
.. list-table:: 論理演算子
    :width: 80%
    :widths: 30, 30, 30
    :header-rows: 1

    * - Python
      - C
      - Fortran

    * - ``A > B``
      - ``A > B``
      - ``A > B``

    * - ``A >= B``
      - ``A >= B``
      - ``A >= B``

    * - ``A < B``
      - ``A < B``
      - ``A < B``

    * - ``A <= B``
      - ``A <= B``
      - ``A <= B``

    * - ``A == B``
      - ``A == B``
      - ``A == B``

    * - ``A != B``
      - ``A != B``
      - ``A /= B``

    * - ``A > B and A > C``
      - ``A > B && A > C``
      - ``A > B .and. A > C``

    * - ``A > B or A > C``
      - ``A > B || A > C``
      - ``A > B .or. A > C``

    * - ``not A > B``
      - ``! (A > B)``
      - ``.not. A > B``



以下は論理演算子を使って様々な条件を組み合わせた例である．演算子の組み合わせにはあらかじめ決められた優先順位に応じて順次評価されるが，カッコで明示的に示したほうが分かりやすい．

.. literalinclude:: sample/chap03/sample1.py
  :lines: 52-61
  :lineno-match:
  :caption: :doc:`sample1.py <chap03_sample1_py>` 抜粋


ちなみにPythonにはCの ``switch`` ，Fortranの ``select`` に対応する構文は存在しないので， ``if`` と ``elif`` で地道に条件判定をつないでいくことになる．


反復処理( ``for`` )
===================

Pythonにおける反復処理（ループ）の最も基本的な形は以下のようなものである．

.. literalinclude:: sample/chap03/sample2.py
  :lines: 9-10
  :lineno-match:
  :caption: :doc:`sample2.py <chap03_sample2_py>` 抜粋

これを実行すると0, 1, 2, 3, 4が順に出力される．もう少し細かい制御をするのであれば

::

  for i in range(start, stop, increment):
      print(i)

のようになる．これによって，ループ変数 ``i`` が ``i = start`` から ``increment`` ずつ変化しながら ``i < stop`` を満たす限りループの中身が実行さる．ここで ``start`` ， ``stop`` ， ``increment`` は全て整数（または整数型の変数）である必要がある．

これはCなら

.. code-block:: c

  for(int i=start; i < stop ;increment++) {
    printf(i);
  }

Fortranなら

.. code-block:: fortran

  do i = start, stop-1, increment
    print *, i
  end do

に対応する．なお ``range(5)`` のように1つしか数値を与えなかった場合は，与えられた数値は上記の ``stop`` と解釈され， ``start = 0``, ``increment = 1`` が指定されたものとみなす．

このようにPythonの ``for`` ループはCのそれと非常に似通っており，またFortranの ``do`` ループとも細かい違いを除けば同じように使うことが出来るので，まずはこの使い方が理解できていれば問題ない [#]_．

当然ながら，以下のように入れ子にすることで多重ループにすることも可能である．

.. literalinclude:: sample/chap03/sample2.py
  :lines: 18-20
  :lineno-match:
  :caption: :doc:`sample2.py <chap03_sample2_py>` 抜粋


反復処理( ``while`` )
=====================

``while`` を使って ``for`` の場合と同様に0, 1, 2, 3, 4を出力するループは以下のように書くことができる．

.. literalinclude:: sample/chap03/sample3.py
  :lines: 9-12
  :lineno-match:
  :caption: :doc:`sample3.py <chap03_sample3_py>` 抜粋

ただし ``i += 1`` は ``i = i + 1`` と同じ，また ``i -= 1`` であれば ``i = i - 1`` と同じ意味である．これらの文法はCと同じであるがFortranにはない書き方である．（ただしインクリメント演算子 ``++`` やデクリメント演算子 ``--`` はPythonには存在しない．）

この例では ``for`` と基本的に同じ動作をするものであるが， ``while`` はループの終了判定に任意の条件式を用いることができるため，あらかじめ回数の決まっていないループの実行など，より細かい制御を行うことができる．例えば変数 ``x`` の値が十分小さくなるまで反復計算をするには

::

  x = 1.0
  while abs(x) > 1.0e-10:
      print('x is not small enough')
      # xがゼロに近づくまで何かの計算をする

のような処理を行なうことになる．この例もCなら

.. code-block:: c

  double x = 1.0;
  while( abs(x) > 1.0e-10 ) {
    // 何かの計算
  }

Fortranなら

.. code-block:: fortran

  real(8) :: x = 1.0
  do while( x > 1.0e-10 )
    ! 何かの計算
  end do


以下はテイラー展開の公式を持ちいて， :math:`sin(x)` の値が組み込み関数で求められる値（真の値）に十分近づくまで反復計算をする例である．

.. literalinclude:: sample/chap03/sample3.py
  :lines: 14-32
  :lineno-match:
  :caption: :doc:`sample3.py <chap03_sample3_py>` 抜粋

この部分の実行結果は以下のようになる．

.. code-block:: bash

  $ python sample3.py
  i =  1  --- sin(x) =  0.2
  i =  3  --- sin(x) =  0.19866666666666669
  i =  5  --- sin(x) =  0.19866933333333336
  i =  7  --- sin(x) =  0.19866933079365082
  approximated =  0.19866933079365082
  exact        =  0.19866933079506122
  rel. error   =  7.0992315183418576e-12

このような場合は繰り返しの回数が事前には分からないので， ``for`` を使うよりも ``while`` を使う方が素直に処理を記述することができる．


複雑な反復処理
==============

``for`` ， ``while`` のいずれも ``continue`` や ``break`` で，より細かいループの制御を行なうことができる [#]_．使い方はCのそれと同じである．Fortranでは ``continue`` は ``cycle`` ， ``break`` は ``exit`` と同じ意味である．

以下の例は ``condition1`` が満たされたときに「処理1」を， ``condition2`` が満たされたときに「処理2」を，どちらも満たされなかったときには「処理3」を実行する．
::

  for i in range(10):
      if   condition1:
          # 処理1
          break
      elif condition2:
          # 処理2
          continue
      # 処理3


以下の例は ``while`` ループで ``continue`` や ``break`` を使う例である．

.. literalinclude:: sample/chap03/sample4.py
  :lines: 8-23
  :lineno-match:
  :caption: :doc:`sample4.py <chap03_sample4_py>` 抜粋

実行結果が以下のようになることは明らかであろう．

.. code-block:: bash

  $ python sample4.py
  Multiple of 2 ---  2
  Multiple of 3 ---  3
  Multiple of 2 ---  4
  Multiple of 5 ---  5
  Multiple of 2 ---  6
  Not a multiple of 2, 3, 5 ---  7
  Multiple of 2 ---  8
  Multiple of 3 ---  9
  Multiple of 2 ---  10
  Exit


関数
====

複雑でまとまった処理を関数としてあらかじめ定義しておくことで，それを様々な場所から呼び出して使うことができて便利である．関数の詳細にはは触れずに，まずは最も基本的な使い方だけを身につけよう．

簡単な例
--------

まずは :doc:`sample5.py <chap03_sample5_py>` を見てみよう．

.. literalinclude:: sample/chap03/sample5.py
  :linenos:
  :caption: :doc:`sample5.py <chap03_sample5_py>`

ここで5-6行目が関数の定義である．ここでは与えられた引数の2乗を計算し，その値を返す ``square`` という関数を定義している．9行目がこの関数の呼び出しであり，引数 ``x`` の2乗を計算した返値を変数 ``y`` に代入している．実行結果は以下のようになるだろう．

.. code-block:: bash

  $ python sample1.py
  square of  2.0  is  4.0

定義
----

Pythonにおける関数定義は以下のように ``def`` を用いて行えばよい．

::

  def 関数名(引数1, 引数2, ...):
      関数内の処理(インデントに注意)

ここでもインデントによって関数定義ブロックとそれ以外を区別していることに注意しよう． ``def`` の次の行のインデントが終わるまでが関数定義とみなされる．先ほどの例 ``square`` では引数は一つであったが，複数の場合はカンマ ``,`` で区切って並べればよい．これらが関数への入力となる [#]_．

関数の定義位置には注意が必要である．Pythonはコンパイル型の言語ではないため，上から順に実行され，実行時に各行が評価される．したがって， **関数定義は呼び出しよりも必ず前にされていなければならない** のである．ただし，これはあくまで実行時の順序であってソースコード上での位置(行数)を意味するものではない．以下の例を見てみよう．

.. literalinclude:: sample/chap03/sample6.py
  :linenos:
  :caption: :doc:`sample6.py <chap03_sample6_py>`

コメントアウトされている5行目の ``hello1`` ，12行目の ``hello2`` の呼び出しはどちらもれエラーとなる．5行目は，この時点で ``hello1`` が定義されていないので明らかである．一方で12行目については，この時点で ``hello2`` が定義されているので一見問題ないように見えるが， ``hello2`` の内部(8行目)で呼び出される ``hello1`` がまだ定義されていないのでエラーになるのである．

返値
----

関数から呼び出し元に制御を戻すときには ``return`` を用いる． ``return`` には関数の返値を指定することもできるが，省略することもできる．このときはデフォルトで ``None`` を返す [#]_．なお， ``return`` がなくても関数定義ブロックの最後まで到達したときには呼び出し元に制御が戻り， ``None`` が返値となる．Fortranでは関数とサブルーチンが区別されているが，Pythonではサブルーチンは存在せず， ``None`` を返す関数がFortranのサブルーチンに相当すると考えておけばよいだろう．

変数のスコープ
--------------

関数の中では自由に変数を定義して使うことができる．例えば以下の例をみてみよう．

.. literalinclude:: sample/chap03/sample7.py
  :lines: 6-13
  :lineno-match:
  :caption: :doc:`sample7.py <chap03_sample7_py>` 抜粋

この関数 ``exp_taylor`` はテイラー展開の公式を ``n`` 次まで用いて ``exp(x)`` の近似値を求める．ここで8行目や9行目のように変数を定義して用いている．これらの変数はローカル変数と呼ばれ，この関数の内部でのみ有効な変数である．すなわちこの関数の外で ``c`` や ``f`` という変数は(これとは別に定義しない限り)定義されない．もし関数の外で同じ名前の変数を定義して用いたとしても，それらはこの関数内の変数とは全く無関係である．

一方で，関数の外で定義された変数に関数内からアクセスしたいこともあるかもしれない．例えば，以下の関数 ``fibonacci`` は呼ばれるたびにフィボナッチ数列を返す関数である．

.. literalinclude:: sample/chap03/sample7.py
  :lines: 16-26
  :lineno-match:
  :caption: :doc:`sample7.py <chap03_sample7_py>` 抜粋

では ``a`` ， ``b`` という変数は関数の外(トップレベル)で定義された変数であり，これらに以前の数列の値を保持している．このような変数をグローバル変数と呼ぶ．関数 ``fibonacci`` からこれらの変数にアクセスするには22行目のように ``global`` を用いて，グローバル変数を用いることを明示する．この例では ``a`` および ``b`` は関数内で値が更新されているが，これによってグローバル変数の値も更新される．

このように関数内では基本的に関数内部でのみ有効なローカル変数を用い，グローバル変数へのアクセスが必要なときのみ，それを ``global`` によって明示すればよい [#]_．ただし，グローバル変数は気をつけて使わないとバグの原因となりやすいため推奨できない．引数を使って明示的に値を渡すか，場合によってはクラスを用いて実装する方がよいことが多い．


..
.. 課題
..

.. include:: kadai/chap03_kadai.rst

-----

.. [#]

  巷で出くわすPythonのループは例えば

  ::

    l = ['a', 'b', 'c']

    for index, name in enumerate(l):
        print(index, name)

  のように複雑怪奇なものが多いことに気がつくであろう．これはイテレータなるものを使って反復処理をもう少し一般的にしたものである．これは少しばかり高度な話題なのでまずは置いておくことにしよう．

.. [#]

  ``else`` 節という構文もあるが，それほど重要ではないのでここでは省略する．

.. [#]

  引数を入力だけでなく出力として用いることも可能である．しかしこれには少し複雑な事情があるので，ここでは最も基本的な使い方である引数を入力とし返値を出力とする使い方をまずは覚えておこう．

.. [#]

  これは「何でもない」ということを示すPythonに組み込みのオブジェクトである

.. [#]

  厳密に言うともう少し複雑な振る舞いをするのだが，グローバル変数を使う際には明示的に ``global`` を付けておいた方が可読性の観点からよいので，このような記述にとどめた．
