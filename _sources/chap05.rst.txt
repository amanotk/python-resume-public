.. -*- coding: utf-8 -*-

.. highlight:: python
  :linenothreshold: 1

================
便利な組み込み型
================

Pythonの強みは言語そのものよりも，付属する協力なライブラリ群にあると言える．ここではPython本体に組み込まれているオブジェクト(データ型)の中でも最も頻繁にお目にかかるであろうもののうちいくつかを簡単に紹介する．ここで紹介するのはあくまで基本中の基本なので，本格的に使うにはこれだけでは少々心もとないが，これをマスターしておけばあとは各自で調べることができるであろう．


.. contents:: この章の内容
    :depth: 2


tuple
=====
tuple(タプル)と呼ばれるオブジェクトは配列のように複数の値をひとまとめにしたものである．後述のlistと同様に，とりあえずはCやFortranの配列と同じようなものとして考えてもらって構わない．

tupleは複数の値を ``()`` と ``,`` (カンマ)で以下のように表される

::

  >>> (1, 2, 3)
  (1, 2, 3)

これは3つの整数要素から成るtupleを表す．

配列とは異なり，tupleの要素として任意のPythonオブジェクトを格納できる．また ``()`` は空の(要素が何もない)tupleを表す．なお，tupleの各要素は ``[]`` で参照することができる．これらを以下の例で確かめてみよう．

::

  >>> ()                           # 空のtuple
  ()
  >>> a = ('this', 'is', 'tuple')  # tupleオブジェクトを変数aに格納
  >>> (1, 'string', a)             # 異なる型のオブジェクトも格納できる
  (1, 'string', ('this', 'is', 'tuple'))
  >>> a[0]                         # aの最初の要素を参照
  'this'


tupleの大きな特徴は **要素の値を変更することができない** という点である．要素の値を書き換えようとすると以下のようなエラーとなる．

::

  >>> a[0] = 'that'
  TypeError: 'tuple' object does not support item assignment


tupleは複数の値を一時的にまとめて扱いたいときによく使われるものなので，その要素を書き換えることは想定されていないのである．典型的な使い方の一つとして，関数から複数の値を返したいときなどに使われる．例えば以下の ``test_tuple`` は与えられた2つの引数の和と差を返す関数である．

::

  >>> def test_tuple(a, b):
  ...     return a+b, a-b
  ...
  >>> test_tuple(1, 2)
  (3, -1)
  >>> c, d = test_tuple(20, 10)
  >>> c
  30
  >>> d
  10


この例のように，実はtupleを作成するときの ``()`` は省略することができる． ここでは ``return a+b, a-b`` で要素2のtuple ``(a+b, a-b)`` を関数の返値としている．また，関数の返値としてtupleが返されるときは，その要素をそれぞれ別の変数に代入して使うことができる(この例では ``c``, ``d``)．なお，これらの変数はtupleではないので，当然変更も可能である．


list
====

基本的にはlistは要素の書き換えができるtupleと考えてよい．tupleの例をそのままlistに置き換えてみよう．

::

  >>> []
  []
  >>> a = ['this', 'is', 'list']
  >>> [1, 'string', a]
  [1, 'string', ['this', 'is', 'list']]
  >>> a[0]
  'this'
  >>> a[0] = 'that' # 自由に要素の書き換えができる
  >>> a
  ['that', 'is', 'list']


listはCやFortranの配列と異なり値の挿入，追加，削除などが自在にできる．使い方は以下の例を見れば明らかだろう．

::

  >>> a = [1, 2, 3]             # 初期化
  >>> a.append(4)               # 最後に新しい要素を追加
  >>> a
  [1, 2, 3, 4]
  >>> a.insert(1, 100)          # 1番目に要素100を追加
  >>> a
  [1, 100, 2, 3, 4]
  >>> a.remove(100)             # 要素100を削除(複数ある場合は最初に見つかった要素)
  >>> a
  [1, 2, 3, 4]
  >>> a.pop()                   # 最後の要素削除
  4
  >>> a
  [1, 2, 3]
  >>> a.extend([10, 11, 12])    # 引数に受け取ったリストの各要素を追加
  >>> a
  [1, 2, 3, 10, 11, 12]
  >>> a.clear()                 # 空にする
  >>> a
  []


注意すべきはlistの長さを伸ばす ``append``, ``extend`` を多用すると一般的には遅くなる可能性が高いということである．基本的には大規模なデータの格納にはlistは使わない [#usenumpy]_ ，また何らかの理由で使わざるを得ないときにはサイズが予め分かっているのであれば最初にその長さのリストを作っておく(サイズを変更しない)，という方針にすべきである．

また，以下のようにtupleをlistに変換することもできる．

::

  >>> list((3, 4, 5)) # tuple (3, 4, 5) をlistに変換
  [3, 4, 5]


なお，任意のサイズの初期化されたlistは簡単に作ることができる．例えば以下の例は0で初期化されたサイズ10のlistを作る例である．

::

  >>> [0]*10
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

ループで ``append`` を繰り返して作るという無駄なことは絶対にやめよう．

listを生成するときに｢内包表記｣を使うと便利なことも多い．例えば

::

  >>> [i**2 for i in range(5)]
  [0, 1, 4, 9, 16]

のように用いる．ただし，慣れるまでは難しいかもしれないので無理して用いる必要はない．


range
=====
これまでも ``for`` ループで繰り返し回数を指定するときに ``for i in range(10)`` のような書き方をしてきた．rangeは整数列を表すという点を除けば，listやtupleと同じように値の列を表すオブジェクトである．(従ってtuple, list, rangeを総称してシーケンス型と呼ぶ．)

rangeは規則的な数列を表すオブジェクトであるため実際にはメモリ上に値を保持せず，必要に応じて値を計算する．すなわち，tupleやlistと異なり，常に使用するメモリは一定であるという特徴がある．(したがって ``for`` ループなどでの使用に向いている．)

必要であれば，以下のようにlistやtupleに簡単に変換することが可能である．

::

  >>> list(range(5))
  [0, 1, 2, 3, 4]
  >>> tuple(range(5))
  (0, 1, 2, 3, 4)


dict
====
dictは辞書(dictionary)や連想配列などと呼ばれるオブジェクトである．


..
.. 課題
..

.. .. include:: kadai/chap04_kadai.rst

-----

.. [#usenumpy]

  ほとんどの場合はNumPy配列を使えば十分なハズである． :doc:`chap06` 参照．
