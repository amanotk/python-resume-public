.. -*- coding: utf-8 -*-

.. highlight:: python
  :linenothreshold: 1

============================
制御構造と関数・オブジェクト
============================

ここでは ``if`` による条件分岐， ``for`` や ``while`` による反復処理，さらには関数の基本的な使い方や，オブジェクトの基本についても学ぼう．

.. seealso::

  `sample.ipynb <sample/chap04/sample.html>`_ (`ダウンロード <sample/chap04/sample.ipynb>`_)

.. contents:: この章の内容
    :depth: 2


.. _label_chap04_if:

条件分岐( ``if`` )
==================

Pythonでも基本的な考え方は他の多くのプログラミング言語と同じで，なんらかの値の真偽に応じて処理の流れを分岐する．例えば ``status`` という変数の真偽に応じて処理を分岐するには

::

  >>> status = True
  >>> 
  >>> # ifによる分岐
  >>> if status:
  ...     print('status is True')  # インデントが１段下がる
  ... else:
  ...     print('status is False') # ここも１段下がる
  status is True

のように記述すればよい．ここでインデントが構文ブロックの区切りであったことを思い出して欲しい． ``if`` に限らず至るところでインデントが必要になるので注意しよう．

なお ``else`` 節は必要なければ省略することが可能である．CやFortranと異なり，条件式の部分にカッコが必要ないことに注意しよう．（ただしカッコがあっても文法的には誤りではない．）さらに， ``if`` を入れ子にするなどのより細かい制御の例として以下を見てみよう．

::

  >>> # 入れ子にするなどより細かい制御
  >>> a = 1
  >>> b = 2
  >>> c = 3
  >>> 
  >>> if a:
  ...     print('a = ', a)
  ...     # ifを入れ子にする
  ...     if a + b > c:
  ...         print('a + b > c')
  ...     elif a + b < c:
  ...         print('a + b < c')
  ...     elif a + b == c:
  ...         # さらに入れ子にする
  ...         if c >= 0:
  ...             print('a + b = c and c >= 0')
  ...         else:
  ...             print('a + b = c and c <  0')
  ...     else:
  ...         # passを使って「何もしない」ことを明示することもできる
  ...         pass
  >>> # トップレベルのifに対応するelseは省略
  a =  1
  a + b = c and c >= 0

なお21行目の ``pass`` は「何もしない」という意味の文である． ``else`` 節は省略できるので，わざわざここに ``pass`` は使う必要はないのだが，場合によっては「何もしない」ことを明示しておくことでプログラムが理解しやすくなることもある．


ここで分岐に使う条件式についてもコメントしておこう．Fortranでは条件式は真偽値(``logical`` 型の変数，または ``.true.`` ， ``.false.`` のいずれか)に限られていた．それに対して，Pythonの場合はCに近くなっている．すなわち，Python組み込みのbool型である ``True`` や ``False`` （これらはPythonの予約済みキーワードで大文字小文字は区別される）だけでなく，任意の型の変数を使うことが出来る．詳細は省くが，とりあえずはCと同様に整数型では ``0`` が偽とみなされ，それ以外は真とみなされるとおぼえておけばよいだろう．また複雑な条件判定には論理演算子である ``and`` ， ``or`` ， ``not`` を組合わせることになる．以下のテーブルには条件判定によく使われる演算子およびその組み合わせの代表的な例を示す．なお，PythonはCやFortranよりも演算子が多い(例えば ``is`` 演算子)のだが，ここではそれには触れないことにする．

.. tabularcolumns:: |p{0.3 \textwidth}|p{0.3 \textwidth}|p{0.3 \textwidth}|
.. list-table:: 論理演算子
    :width: 80%
    :widths: 30, 30, 30
    :header-rows: 1

    * - Python
      - C
      - Fortran

    * - ``A > B``
      - ``A > B``
      - ``A > B``

    * - ``A >= B``
      - ``A >= B``
      - ``A >= B``

    * - ``A < B``
      - ``A < B``
      - ``A < B``

    * - ``A <= B``
      - ``A <= B``
      - ``A <= B``

    * - ``A == B``
      - ``A == B``
      - ``A == B``

    * - ``A != B``
      - ``A != B``
      - ``A /= B``

    * - ``A > B and A > C``
      - ``A > B && A > C``
      - ``A > B .and. A > C``

    * - ``A > B or A > C``
      - ``A > B || A > C``
      - ``A > B .or. A > C``

    * - ``not A > B``
      - ``! (A > B)``
      - ``.not. A > B``



以下は論理演算子を使って様々な条件を組み合わせた例である．演算子の組み合わせにはあらかじめ決められた優先順位に応じて順次評価されるが，カッコで明示的に示したほうが分かりやすい．

::

  >>> if a < b and a < c:
  ...     print('a is smaller than both b and c')
  a is smaller than both b and c

  >>> if a < b or a < c:
  ...     print('a is smaller than either b or c')
  a is smaller than either b or c

  >>> if (a == 1 and a + b == c) or not (a == 1 and b == 2 and c == 3):
  ...     print('example of complex conditional')
  example of complex conditional

ちなみにPythonにはCの ``switch`` ，Fortranの ``select`` に対応する構文は存在しないので， ``if`` と ``elif`` で地道に条件判定をつないでいくことになる．


.. _label_chap04_for:

反復処理( ``for`` )
===================

Pythonにおける反復処理（ループ）の最も基本的な形は以下のようなものである．

これを実行すると0, 1, 2, 3, 4が順に出力される．もう少し細かい制御をするのであれば

::

  >>> for i in range(5):
  ...     print(i)
  0
  1
  2
  3
  4

::

  for i in range(start, stop, increment):
      print(i)

のようになる．これによって，ループ変数 ``i`` が ``i = start`` から ``increment`` ずつ変化しながら ``i < stop`` を満たす限りループの中身が実行さる．ここで ``start`` ， ``stop`` ， ``increment`` は全て整数（または整数型の変数）である必要がある．

これはCなら

.. code-block:: c

  for(int i=start; i < stop ;increment++) {
    printf(i);
  }

Fortranなら

.. code-block:: fortran

  do i = start, stop-1, increment
    print *, i
  end do

に対応する．なお ``range(5)`` のように1つしか数値を与えなかった場合は，与えられた数値は上記の ``stop`` と解釈され， ``start = 0``, ``increment = 1`` が指定されたものとみなす．明示的にこれらを指定した例を以下に示しておこう．

::

  >>> for i in range(0, 5, 2):
  ...     print('i     = ', i)
  ...     print('i + 1 = ', i+1)
  i     =  0
  i + 1 =  1
  i     =  2
  i + 1 =  3
  i     =  4
  i + 1 =  5

このようにPythonの ``for`` ループはCのそれと非常に似通っており，またFortranの ``do`` ループとも細かい違いを除けば同じように使うことが出来るので，まずはこの使い方が理解できていれば問題ない [#]_．

当然ながら，以下のように入れ子にすることで多重ループにすることも可能である．

::

  >>> for i in range(1, 3):
  ...     for j in range(1, 5):
  ...         print('i = ', i, ', j = ', j, ', i*j = ', i*j)
  i =  1 , j =  1 , i*j =  1
  i =  1 , j =  2 , i*j =  2
  i =  1 , j =  3 , i*j =  3
  i =  1 , j =  4 , i*j =  4
  i =  2 , j =  1 , i*j =  2
  i =  2 , j =  2 , i*j =  4
  i =  2 , j =  3 , i*j =  6
  i =  2 , j =  4 , i*j =  8

もう少し実用的な例として，テイラー展開の公式を用いて :math:`\sin(x)` の近似値を求める例を以下に示す．

::

  >>> import math
  >>> 
  >>> x = 0.2
  >>> 
  >>> print('*** Taylor expansion of sin(x) ***')
  >>> 
  >>> y = x
  >>> a = x
  >>> i = 1
  >>> print('x = ', x)
  >>> print('i = ', i, ' --- sin(x) = ', y)
  >>> 
  >>> for i in range(3, 10, 2):
  ...     a = -a / ((i-1)*i) * x**2
  ...     y = y + a
  ...     print('i = ', i, ' --- sin(x) = ', y)
  >>> 
  >>> print('exact   --- sin(x) = ', math.sin(x))
  *** Taylor expansion of sin(x) ***
  x =  0.2
  i =  1  --- sin(x) =  0.2
  i =  3  --- sin(x) =  0.19866666666666669
  i =  5  --- sin(x) =  0.19866933333333336
  i =  7  --- sin(x) =  0.19866933079365082
  i =  9  --- sin(x) =  0.19866933079506174
  exact   --- sin(x) =  0.19866933079506122


.. _label_chap04_while:

反復処理( ``while`` )
=====================

``while`` を使って ``for`` の場合と同様に0, 1, 2, 3, 4を出力するループは以下のように書くことができる．

::

  >>> i = 0
  >>> while i < 5:
  ...     print(i)
  ...     i += 1
  0
  1
  2
  3
  4

ただし ``i += 1`` は ``i = i + 1`` と同じ，また ``i -= 1`` であれば ``i = i - 1`` と同じ意味である．これらの文法はCと同じであるがFortranにはない書き方である．（ただしインクリメント演算子 ``++`` やデクリメント演算子 ``--`` はPythonには存在しない．）

この例では ``for`` と基本的に同じ動作をするものであるが， ``while`` はループの終了判定に任意の条件式を用いることができるため，あらかじめ回数の決まっていないループの実行など，より細かい制御を行うことができる．例えば変数 ``x`` の値が十分小さくなるまで反復計算をするには

::

  >>> x = 1.0
  >>> while abs(x) > 1.0e-10:
  ...    print('x is not small enough')
  ...    # xがゼロに近づくまで何かの計算をする

のような処理を行なうことになる．この例もCなら

.. code-block:: c

  double x = 1.0;
  while( abs(x) > 1.0e-10 ) {
    // 何かの計算
  }

Fortranなら

.. code-block:: fortran

  real(8) :: x = 1.0
  do while( x > 1.0e-10 )
    ! 何かの計算
  end do

と同様である．以下はテイラー展開の公式を持ちいて， :math:`\sin(x)` の値が組み込み関数で求められる値（真の値）に十分近づくまで反復計算をする例である．

::

  >>> import math
  >>> 
  >>> x = 0.2
  >>> i = 1
  >>> y = x
  >>> a = x
  >>> ytrue = math.sin(x)
  >>> print('i = ', i, ' --- sin(x) = ', y)
  >>> 
  >>> while abs((ytrue - y)/ytrue) > 1.0e-10:
  ...     i += 2
  ...     a = -a / ((i-1)*i) * x**2
  ...     y = y + a
  ...     print('i = ', i, ' --- sin(x) = ', y)
  >>> 
  >>> print('approximated = ', y)
  >>> print('exact        = ', ytrue)
  >>> print('rel. error   = ', abs((ytrue-y)/ytrue))
  i =  1  --- sin(x) =  0.2
  i =  3  --- sin(x) =  0.19866666666666669
  i =  5  --- sin(x) =  0.19866933333333336
  i =  7  --- sin(x) =  0.19866933079365082
  approximated =  0.19866933079365082
  exact        =  0.19866933079506122
  rel. error   =  7.0992315183418576e-12

このような場合は繰り返しの回数が事前には分からないので， ``for`` を使うよりも ``while`` を使う方が素直に処理を記述することができる．


.. _label_chap04_complexloop:

複雑な反復処理
==============

``for`` ， ``while`` のいずれも ``continue`` や ``break`` で，より細かいループの制御を行なうことができる [#]_．使い方はCのそれと同じである．Fortranでは ``continue`` は ``cycle`` ， ``break`` は ``exit`` と同じ意味である．

以下の例は ``condition1`` が満たされたときに「処理1」を， ``condition2`` が満たされたときに「処理2」を，どちらも満たされなかったときには「処理3」を実行する．
::

  for i in range(10):
      if   condition1:
          # 処理1
          break
      elif condition2:
          # 処理2
          continue
      # 処理3


以下の例は ``while`` ループで ``continue`` や ``break`` を使う例である．

::

  >>> i = 1
  >>> while True:
  ...     i += 1
  ...     if   i%2 == 0:
  ...         print('Multiple of 2 --- ', i)
  ...         continue
  ...     elif i%3 == 0:
  ...         print('Multiple of 3 --- ', i)
  ...         continue
  ...     elif i%5 == 0:
  ...         print('Multiple of 5 --- ', i)
  ...         continue
  ...     elif i >= 10:
  ...         print('Exit')
  ...         break
  ...     print('Not a multiple of 2, 3, 5 --- ', i)
  Multiple of 2 ---  2
  Multiple of 3 ---  3
  Multiple of 2 ---  4
  Multiple of 5 ---  5
  Multiple of 2 ---  6
  Not a multiple of 2, 3, 5 ---  7
  Multiple of 2 ---  8
  Multiple of 3 ---  9
  Multiple of 2 ---  10
  Exit


.. _label_chap04_function:

関数
====

複雑でまとまった処理を関数としてあらかじめ定義しておくことで，それを様々な場所から呼び出して使うことができて便利である．関数の詳細には触れずに，まずは最も基本的な使い方だけを身につけよう．


簡単な例
--------

まずは以下の例を見てみよう．

::

  >>> # 関数定義
  >>> def square(x):
  ...     return x**2
  >>> 
  >>> # 関数呼び出し
  >>> square(2.0)
  4.0

ここで2-3行目が関数の定義である．ここでは与えられた引数の2乗を計算し，その値を返す ``square`` という関数を定義している．6行目がこの関数の呼び出しであり，引数の2乗を計算した値が返ってきたのが分かる．


定義
----

Pythonにおける関数定義は以下のように ``def`` を用いて行えばよい．

::

  def 関数名(引数1, 引数2, ...):
      関数内の処理(インデントに注意)

ここでもインデントによって関数定義ブロックとそれ以外を区別していることに注意しよう． ``def`` の次の行のインデントが終わるまでが関数定義とみなされる．先ほどの例 ``square`` では引数は一つであったが，複数の場合はカンマ ``,`` で区切って並べればよい．これらが関数への入力となる [#]_．

関数の定義位置には注意が必要である．Pythonはコンパイル型の言語ではないため，上から順に実行され，実行時に各行が評価される．したがって， **関数定義は呼び出しよりも必ず前にされていなければならない** のである．ただし，これはあくまで実行時の順序であってソースコード上での位置(行数)を意味するものではない．以下の例を見てみよう．

::

  >>> # 以下の呼び出しはエラー(この時点ではhelloは定義されていない)
  >>> #hello1()
  >>> 
  >>> def hello2(name):
  ...     hello1() # 実行時にhello1が定義済みであればOK
  ...     print('I am', name)
  >>> 
  >>> # 以下の呼び出しもエラー(この時点ではhello2が呼び出すhello1は定義されていない)
  >>> #hello2('John')
  >>> 
  >>> def hello1():
  ...     print('Hello')
  >>> 
  >>> hello1()
  >>> hello2('John')
  Hello
  Hello
  I am John

コメントアウトされている2行目の ``hello1`` ，9行目の ``hello2`` の呼び出しはどちらもれエラーとなる．2行目は，この時点で ``hello1`` が定義されていないので明らかである．一方で9行目については，この時点で ``hello2`` が定義されているので一見問題ないように見えるが， ``hello2`` の内部(5行目)で呼び出される ``hello1`` がまだ定義されていないのでエラーになるのである．これはJupyter Notebookを常用しているとセルの評価順序がバラバラになってしまうので曖昧になりやすい点なので注意しておこう．


返値
----

関数から呼び出し元に制御を戻すときには ``return`` を用いる． ``return`` には関数の返値を指定することもできるが，省略することもできる．このときはデフォルトで ``None`` を返す [#]_．なお， ``return`` がなくても関数定義ブロックの最後まで到達したときには呼び出し元に制御が戻り， ``None`` が返値となる．Fortranでは関数とサブルーチンが区別されているが，Pythonではサブルーチンは存在せず， ``None`` を返す関数がFortranのサブルーチンに相当すると考えておけばよいだろう．


変数のスコープ
--------------

関数の中では自由に変数を定義して使うことができる．例えば以下の例をみてみよう．

::

  >>> import math
  >>> 
  >>> # approximation of exp(x) via taylor expansion up to order n
  >>> def exp_taylor(x, n):
  ...     c = 1.0
  ...     f = 1.0
  ...     for i in range(n):
  ...         c /= (i+1)
  ...         f += c * x**(i+1)
  ...     return f
  >>> 
  >>> print('--- exp_taylor ---')
  >>> x = 0.5
  >>> print('x     = ', x)
  >>> print('1st   = ', exp_taylor(x, 1))
  >>> print('2nd   = ', exp_taylor(x, 2))
  >>> print('3rd   = ', exp_taylor(x, 3))
  >>> print('4th   = ', exp_taylor(x, 4))
  >>> print('5th   = ', exp_taylor(x, 5))
  >>> print('6th   = ', exp_taylor(x, 6))
  >>> print('7th   = ', exp_taylor(x, 7))
  >>> print('8th   = ', exp_taylor(x, 8))
  >>> print('exact = ', math.exp(x))
  --- exp_taylor ---
  x     =  0.5
  1st   =  1.5
  2nd   =  1.625
  3rd   =  1.6458333333333333
  4th   =  1.6484375
  5th   =  1.6486979166666667
  6th   =  1.6487196180555554
  7th   =  1.6487211681547618
  8th   =  1.6487212650359622
  exact =  1.6487212707001282

この関数 ``exp_taylor`` はテイラー展開の公式を ``n`` 次まで用いて ``exp(x)`` の近似値を求める．ここで5行目や6行目のように変数を定義して用いている．これらの変数はローカル変数と呼ばれ，この関数の内部でのみ有効な変数である．すなわちこの関数の外で ``c`` や ``f`` という変数は(これとは別に定義しない限り)定義されない．もし関数の外で同じ名前の変数を定義して用いたとしても，それらはこの関数内の変数とは全く無関係である．

一方で，関数の外で定義された変数に関数内からアクセスしたいこともあるかもしれない．例えば，以下の関数 ``fibonacci`` は呼ばれるたびにフィボナッチ数列を返す関数である．

::

  >>> # global variables for fibonacci
  >>> a =-1
  >>> b = 1
  >>> 
  >>> def fibonacci():
  ...     # a and b refer to the global variables
  ...     global a, b
  ...     c = a + b
  ...     a = b
  ...     b = c
  ...     return c
  >>> 
  >>> print('--- fibonacci ---')
  >>> for i in range(20):
  ...     print(fibonacci())
  --- fibonacci ---
  0
  1
  1
  2
  3
  5
  8
  13
  21
  34
  55
  89
  144
  233
  377
  610
  987
  1597
  2584
  4181

ここでは ``a`` ， ``b`` という変数は関数の外(トップレベル)で定義された変数であり，これらに以前の数列の値を保持している．このような変数をグローバル変数と呼ぶ．関数 ``fibonacci`` からこれらの変数にアクセスするには22行目のように ``global`` を用いて，グローバル変数を用いることを明示する．この例では ``a`` および ``b`` は関数内で値が更新されているが，これによってグローバル変数の値も更新される．

このように関数内では基本的に関数内部でのみ有効なローカル変数を用い，グローバル変数へのアクセスが必要なときのみ，それを ``global`` によって明示すればよい [#]_．ただし，グローバル変数は気をつけて使わないとバグの原因となりやすいため推奨できない．引数を使って明示的に値を渡すか，場合によってはクラスを用いて実装する方がよいことが多い．


.. _label_chap04_object:

オブジェクト
============

ここまではあえて曖昧にしてきたが，実はPythonでは全て(変数，関数，モジュールなど)がオブジェクト(正確には組み込みの ``object`` クラスのインスタンス)である．このことを正確に理解するにはオブジェクト指向の考え方が必要になるので，ここでは詳細には立ち入らない．Pythonはオブジェクト指向についての知識がなくても「なんとなく」使えるという意味で簡単な言語であるが，本格的に使うには，オブジェクト指向やクラス，インスタンス，イテレータなどの少々難解な概念を理解する必要が出てくる．そういう意味ではPythonを本当に使いこなすのは少し難しいかもしれない．Pythonのいいところは初心者でもある程度簡単に使えるのに加えて，上級者には強力な機能を提供しているところと言えるかもしれない．ここではPythonを使うにあたって必要最低限の知識だけを身につけておこう．

属性
----

一般にオブジェクトは属性(attribute)と呼ばれるオブジェクトに紐付けられた変数を持つ．例えば「人間」には「名前」という属性があるし，「学生」には「学生証番号」という属性がある，といった具合にそれぞれのオブジェクトの実体が固有の変数を持っていると考えればよい．

オブジェクトに紐付けられた属性にアクセスするには ``.`` を用いる．例えば ``sys`` というモジュールもオブジェクトなので，いくつかの属性を持っている．以下の例を見てみよう．

::

  >>> import sys
  >>> sys.version
  '3.7.10 (default, Feb 26 2021, 18:47:35) \n[GCC 7.3.0]'

ここでは ``sys.version`` で ``sys`` オブジェクトの ``version`` という属性にアクセスしている．属性は普通の変数と全く同じように用いることができる．


メソッド
--------

属性が変数であったのに対して，メソッド(method)はオブジェクトに紐付けられた関数と考えればよい．例えば「人間」には「走る」という動作があり，「学生」には「学校に行く」という動作がある．メソッドはこのようなオブジェクトの動きを表すものと考えるとよい．ただし，必ずしもオブジェクトの動きを表すようなメソッドでなくてもよく，単にオブジェクトに紐付けられた関数と考えることも多い．

例えばPythonプログラムを終了するには ``sys.exit()`` 関数を使うことは :doc:`chap02` で見た通りであるが，これは ``sys`` オブジェクトの ``exit()`` メソッドを呼び出していると考えればよい．他の例も見てみよう．

::

  >>> s = 'python'
  >>> s.upper()
  'PYTHON'
  >>> s.lower()
  'python'
  >>> s.capitalize()
  'Python'

この例では文字列 ``s`` の メソッド ``upper()`` ， ``lower()`` ， ``capitalize()`` をそれぞれ呼び出している．その名前と実行結果から明らかなように，それぞれ大文字に変換，小文字に変換，先頭だけ大文字で以降は小文字に変換した文字列を返す関数である．


..
.. 課題
..

.. include:: kadai/chap04_kadai.rst

-----

.. [#]

  巷で出くわすPythonのループは例えば

  ::

    l = ['a', 'b', 'c']

    for index, name in enumerate(l):
        print(index, name)

  のように複雑怪奇なものが多いことに気がつくであろう．これはイテレータなるものを使って反復処理をもう少し一般的にしたものである．これは少しばかり高度な話題なのでまずは置いておくことにしよう．

.. [#]

  ``else`` 節という構文もあるが，それほど重要ではないのでここでは省略する．

.. [#]

  引数を入力だけでなく出力として用いることも可能である．しかしこれには少し複雑な事情があるので，ここでは最も基本的な使い方である引数を入力とし返値を出力とする使い方をまずは覚えておこう．

.. [#]

  これは「何でもない」ということを示すPythonに組み込みのオブジェクトである

.. [#]

  厳密に言うともう少し複雑な振る舞いをするのだが，グローバル変数を使う際には明示的に ``global`` を付けておいた方が可読性の観点からよいので，このような記述にとどめた．
